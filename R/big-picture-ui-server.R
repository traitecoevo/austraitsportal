#' User interface (UI) for AusTraits Data Portal

austraits_ui <- function(){
  
  ui <- page_fluid(
    theme = bs_theme(version = 5, bootswatch = "flatly"),
    
    page_navbar(
      title = "Data Explorer",
      
      layout_column_wrap(
        width = 12,
        card(
          card_header(
            div(
              style = "display: flex; justify-content: space-between; align-items: center;",
              h4("Data Table", style = "margin: 0;"),
              div(
                actionButton("clear_filters", "Clear Filters", 
                             class = "btn-warning", icon = icon("trash-alt")),
                downloadButton("download_data", "Download Filtered Data", 
                               class = "btn-primary ms-2", icon = icon("download"))
              )
            )
          ),
          full_screen = TRUE,
          card_body(
            DTOutput("data_table", height = "100%")
          ),
          height = "calc(100vh - 120px)"
        )
      )
    )
  )
}


#' AusTraits Data Portal Server Logic
#'
#' @param input Input list generated by Shiny
#' @param output Output list generated by Shiny
#' @param session Session id for Shiny interaction

austraits_server <- function(input, output, session) {

  # Reactive value to store the displayed data later
  display_data_table <- reactiveVal(NULL)
  
  # Reactive value to store the filtered data later
  filtered_dt_data <- reactiveVal(NULL)
  
  # Put formatted table here
  flat_austraits <- austraits |> flatten_database()
  display_data_table(flat_austraits)
  
  output$data_table <- DT::renderDT({
    # Get the display data
    display_data <- display_data_table()
    
    # Return NULL or empty table if no data
    if (is.null(display_data)) {
      return(datatable(data.frame(), options = list(pageLength = 10)))
    }
    
    datatable(
      data = display_data,
      options = list(
        dom = 'lftip',
        pageLength = 10,
        scrollX = TRUE,
        searchHighlight = TRUE,
        columnDefs = list(list(searchable = TRUE, targets = "_all")),
        # Add callback to capture filtered data
        initComplete = JS("
        function(settings, json) {
          var table = this.api();
          
          // Update filtered data when searching/filtering happens
          table.on('search.dt', function() {
            var filteredData = table.rows({search: 'applied'}).data().toArray();
            Shiny.setInputValue('filtered_data', filteredData);
          });
          
          // Initial set of filtered data
          var initialFilteredData = table.rows({search: 'applied'}).data().toArray();
          Shiny.setInputValue('filtered_data', initialFilteredData);
        }
      ")
      ),
      rownames = FALSE,
      filter = 'top',
      class = 'cell-border stripe',
      callback = JS("table")  # This makes the table object available to JavaScript
    )
  })
  
  
  observe({
    # Check if filtered_data input exists
    if (!is.null(input$filtered_data)) {
      # Convert the filtered data to a data frame
      filtered_df <- as.data.frame(input$filtered_data)
      filtered_dt_data(filtered_df)
    }
  })
  
  # Download handler
  output$download_data <- downloadHandler(
    filename = function() {
      paste("austraits-filtered-", Sys.Date(), ".csv", sep = "")
    },
    content = function(file) {
      # Get the filtered data from the DataTable
      filtered_data <- filtered_dt_data()
      
      # If no filtered data is available, fall back to the full data
      if (is.null(filtered_data) || nrow(filtered_data) == 0) {
        data_to_download <- download_data_table()
        
        # Handle NULL or empty data case
        if (is.null(data_to_download) || nrow(data_to_download) == 0) {
          data_to_download <- data.frame(message = "No data selected")
        }
      } else {
        data_to_download <- filtered_data
      }
      
      utils::write.csv(data_to_download, file, row.names = FALSE)
    }
  )
}