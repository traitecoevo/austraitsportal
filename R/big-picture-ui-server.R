#' User interface (UI) for AusTraits Data Portal

austraits_ui <- function(){
  
  ui <- page_fluid(
    
    title = "AusTraits Data Explorer",
    theme = bs_theme(version = 5, bootswatch = "flatly"),
    
    page_navbar( # Option to have multiple tabs later
      
      nav_panel(
        title = "Data table",
        layout_column_wrap(
          width = 12,
          card(
            card_header(
              div(
                style = "display: flex; justify-content: space-between; align-items: center;",
                h4("Data Table", style = "margin: 0;"),
                div(
                  actionButton("clear_filters", "Clear Filters", 
                               class = "btn-warning", icon = icon("trash-alt")),
                  downloadButton("download_data", "Download Filtered Data", 
                                 class = "btn-primary ms-2", icon = icon("download"))
                )
              )
            ),
            full_screen = TRUE,
            card_body(
              DTOutput("data_table", height = "100%")
            ),
            height = "calc(100vh - 120px)"
          )
        )
      )
    )
  )
}


#' AusTraits Data Portal Server Logic
#'
#' @param input Input list generated by Shiny
#' @param output Output list generated by Shiny
#' @param session Session id for Shiny interaction

# Modify your austraits_server function

austraits_server <- function(input, output, session) {
  # Reactive value to store the displayed data
  display_data_table <- reactiveVal(NULL)
  
  # Reactive value to store the filtered data
  filtered_dt_data <- reactiveVal(NULL)
  
  # Put formatted table here
  flat_austraits <- austraits |> flatten_database()
  display_data_table(flat_austraits)
  
  # Proxy object for the datatable
  proxy <- dataTableProxy("data_table")
  
  output$data_table <- DT::renderDT({
    # Get the display data
    display_data <- display_data_table()
    
    # Return NULL or empty table if no data
    if (is.null(display_data)) {
      return(datatable(data.frame(), options = list(pageLength = 10)))
    }
    
    datatable(
      data = display_data,
      options = list(
        dom = 'lftip',
        pageLength = 10,
        scrollX = TRUE,
        searchHighlight = TRUE,
        columnDefs = list(list(searchable = TRUE, targets = "_all"))
      ),
      rownames = FALSE,
      filter = 'top',
      class = 'cell-border stripe'
    )
  })
  
  # Use server-side processing to track filtered data
  observeEvent(list(input$data_table_search, input$data_table_rows_all), {
    # Get indices of visible rows after filtering
    visible_rows <- input$data_table_rows_all
    
    # If we have visible rows, subset the data
    if (!is.null(visible_rows) && length(visible_rows) > 0) {
      full_data <- display_data_table()
      filtered_data <- full_data[visible_rows, , drop = FALSE]
      filtered_dt_data(filtered_data)
    } else {
      # If no rows are visible, set to empty data frame with same structure
      filtered_dt_data(display_data_table()[0, , drop = FALSE])
    }
  })
  
  # Clear filters button
  observeEvent(input$clear_filters, {
    # Reset the search and filters
    proxy %>% clearSearch() %>% clearFilters()
    # Reset the filtered data to full data
    filtered_dt_data(display_data_table())
  })
  
  # Download handler
  output$download_data <- downloadHandler(
    filename = function() {
      paste("austraits-filtered-", Sys.Date(), ".csv", sep = "")
    },
    content = function(file) {
      # Get the filtered data from our reactive
      filtered_data <- filtered_dt_data()
      
      # If no filtered data is available, fall back to the full data
      if (is.null(filtered_data) || nrow(filtered_data) == 0) {
        data_to_download <- display_data_table()
        
        # Handle NULL or empty data case
        if (is.null(data_to_download) || nrow(data_to_download) == 0) {
          data_to_download <- data.frame(message = "No data selected")
        }
      } else {
        data_to_download <- filtered_data
      }
      
      utils::write.csv(data_to_download, file, row.names = FALSE)
    }
  )
}