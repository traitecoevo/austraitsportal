#' User interface (UI) for AusTraits Data Portal

austraits_ui <- function(){
  
  ui <- page_sidebar(
    
    # Set the overall theme of the app
    theme = bs_theme(preset = "flatly"),
    
    # Title of the portal
    title = "AusTraits Data Portal",
    
    # Create a sidebar for the app
    sidebar = sidebar(
      # Filter by taxonomic information
      h5("Taxonomic information"),
      
      radioButtons("user_taxon_rank", 
                   label = "Filter by which taxon rank:",
                   choices = c('Taxon name' = "taxon_name",
                               'Genus' = "genus", 
                               'Family' = "family"
                   )
      ),
      
      # Only show this panel if Taxon name is selected
      conditionalPanel(
        condition = 'input.user_taxon_rank == "taxon_name"',
        ## By taxon_name
        selectizeInput("user_taxon_name",
                       label = "Taxon name:",
                       choices = NULL,
                       multiple = TRUE)
      ),
      
      # Only show this panel if Genus is selected
      conditionalPanel(
        condition = 'input.user_taxon_rank == "genus"',
        ## By genus
        selectizeInput("user_genus",
                       label = "Genus:",
                       choices = NULL,
                       multiple = TRUE
        )
      ),
      # Only show this panel if family is selected  
      conditionalPanel(
        condition = 'input.user_taxon_rank == "family"',
        ## By family
        selectizeInput("user_family",
                       label = "Family:",
                       choices = NULL,
                       multiple = TRUE
        )
      ),
      
      h5("Contexts information"),
      
      ## By context property
      selectizeInput("user_context_property",
                     label = "Search contexts by keywords:",
                     choices = NULL,
                     multiple = TRUE,
                     options = list(
                       create = TRUE
                       )
      ),
      
      br(),
      actionButton("clear_filters", "Clear Filters", 
                   class = "btn-warning w-100"),
      
      # Download button
      downloadButton("download_data", "Download displayed data")
    ),
    
    # Data display
    card(
      card_header("Data Preview"),
      card_body(
        fillable = TRUE,
        DT::DTOutput("data_table"
                     )
      )
    )
  )
}


#' AusTraits Data Portal Server Logic
#'
#' @param input Input list generated by Shiny
#' @param output Output list generated by Shiny
#' @param session Session id for Shiny interaction

austraits_server <- function(input, output, session) {
  # Initialize dropdown choices for taxonomic information
  taxon_name_choices <- reactive({ all_taxon_names })
  genus_choices <- reactive({ all_genus })
  family_choices <- reactive({ all_family })
  
  # Reactive values for storage
  ## One for taxonomy filters
  filtered_by_taxonomy <- reactiveVal(NULL)
  
  # Final combined filtered data
  filtered_database <- reactiveVal(NULL)
  
  # Update the appropriate selectizeInput when radio button changes
  observeEvent(input$user_taxon_rank, {
    # Reset the filtered database to clear the data preview
    filtered_database(NULL)
    
    if(input$user_taxon_rank == "taxon_name") {
      updateSelectizeInput(
        session,
        "user_taxon_name",
        choices = taxon_name_choices(),
        selected = NULL,
        server = TRUE
      )
    } else if(input$user_taxon_rank == "genus") {
      updateSelectizeInput(
        session,
        "user_genus",
        choices = genus_choices(),
        selected = NULL,
        server = TRUE
      )
    } else if(input$user_taxon_rank == "family") {
      updateSelectizeInput(
        session,
        "user_family",
        choices = family_choices(),
        selected = NULL,
        server = TRUE
      )
    }
  })
  
  # Filter data by taxonomic information
  ## Watch for changes in user_taxon_name
  observeEvent(input$user_taxon_name, {
    # Skip if empty
    if(length(input$user_taxon_name) == 0) {
      filtered_by_taxonomy(NULL)
      return()
    }
    
    # Filter by taxonomic info
    filter_taxonomic_output <- austraits |> 
      extract_taxa(taxon_name = input$user_taxon_name)

    # Store in reactive
    filtered_by_taxonomy(filter_taxonomic_output)
  })
  
  ## Watch for changes in user-genus
  observeEvent(input$user_genus, {
    # Skip if empty
    if(length(input$user_genus) == 0) {
      filtered_by_taxonomy(NULL)
      return()
    }
    
    # Filter by taxonomic info
    filter_taxonomic_output <- austraits |> 
      extract_taxa(genus = input$user_genus)
    
    # Store in reactive
    filtered_by_taxonomy(filter_taxonomic_output)
  })
  
  ## Watch for changes in user-family
  observeEvent(input$user_family, {
    # Skip if empty
    if(length(input$user_family) == 0) {
      filtered_by_taxonomy(NULL)
      return()
    }
    
    # Filter by taxonomic info
    filter_taxonomic_output <- austraits |> 
      extract_taxa(family = input$user_family)
    
    # Store in reactive
    filtered_by_taxonomy(filter_taxonomic_output)
  })

  
  # Update contexts by taxonomic filter if applied
  observe({
    # Get current taxonomy filtered data
    tax_data <- filtered_by_taxonomy()
    
    # Preserve current selection
    current_selections <- input$user_context_property
    
    if(!is.null(tax_data)) {
      
      # Extract the available contexts from the taxonomy-filtered data
      available_contexts <- unique(tax_data$contexts$context_property) |> sort()
      
      # Update the selectizeInput with only the available contexts
      updateSelectizeInput(
        session,
        "user_context_property",
        choices = available_contexts,
        selected = current_selections,  # Keep current selections
        server = TRUE,
        #options = list(
        #   plugins = list('remove_button'),
        #   searchField = 'text',
        #   highlight = TRUE,
        #   create = TRUE
        # )
      )
    } else {
      # If no taxonomy filter is applied, reset to all contexts
      updateSelectizeInput(
        session,
        "user_context_property",
        choices = all_contexts,
        selected = current_selections,  # Preserve current selections
        server = TRUE,
        # options = list(
        #   plugins = list('remove_button'),
        #   searchField = 'text',
        #   highlight = TRUE,
        #   create = TRUE
        # )
      )
    }
  })
  
  # Filter by contexts (with taxonomic) information 
  # Observer that combines both taxonomy and context filters
  # Remove the original observe() block entirely
  
  # Use separate observeEvent() blocks for taxonomy and context filters
  observeEvent(filtered_by_taxonomy(), {
    updateFilters()
  }, ignoreInit = TRUE)
  
  observeEvent(input$user_context_property, {
    updateFilters()
  }, ignoreInit = TRUE)
  
  # Define a helper function to update the filtered database based on current selections
  updateFilters <- function() {
    # Get current taxonomy filtered data
    tax_data <- filtered_by_taxonomy()
    
    # Get context filter values
    context_values <- input$user_context_property
    
    # Case 1: Both taxonomy and context filters are active
    if(!is.null(tax_data) && length(context_values) > 0) {
      tax_context_output <- tax_data |> 
        extract_data(table = "contexts",
                     col = "context_property", 
                     col_value = context_values)
      
      # Store the combined result
      filtered_database(tax_context_output)
    }  
    # Case 2: Only taxonomy filter is active
    else if(!is.null(tax_data) && length(context_values) == 0) {
      filtered_database(tax_data)
    }
    # Case 3: Only context filter is active
    else if(length(context_values) > 0) {
      context_filtered <- austraits |> 
        extract_data(table = "contexts",
                     col = "context_property", 
                     col_value = context_values)
      filtered_database(context_filtered)
    }
    # Case 4: No filters are active
    else {
      filtered_database(NULL)
    }
  }
  
  # Clear filters button action
  observeEvent(input$clear_filters, {
    # Based on which filter is currently active
    if(input$user_taxon_rank == "taxon_name") {
      updateSelectizeInput(
        session,
        "user_taxon_name",
        choices = taxon_name_choices(),
        selected = NULL,
        server = TRUE
      )
    } else if(input$user_taxon_rank == "genus") {
      updateSelectizeInput(
        session,
        "user_genus",
        choices = genus_choices(),
        selected = NULL,
        server = TRUE
      )
    } else if(input$user_taxon_rank == "family") {
      updateSelectizeInput(
        session,
        "user_family",
        choices = family_choices(),
        selected = NULL,
        server = TRUE
      )
    }
    
    # Clear context filter as well
    updateSelectizeInput(
      session,
      "user_context_property",
      choices = all_contexts,
      selected = NULL,
      server = TRUE
    )
    
    # Reset filtered_by_taxonomy() explicitly
    filtered_by_taxonomy(NULL)
    
    # Store nothing in filtered_data()
    filtered_database(NULL)
    
    # Show notification
    showNotification("Filters have been cleared", 
                     type = "message", 
                     duration = 3)
  })
  
  # Set up display data as reactive expression
  display_data_table <- reactive({
    # Get the current filtered database
    filtered_db <- filtered_database()
    
    # Check if it's NULL and return appropriate value
    if (is.null(filtered_db)) {
      return(NULL)
    }
    
    # Format the database for display
    format_database_for_display(filtered_db)
  })
  
  # Set up download data as reactive expression  
  download_data_table <- reactive({
    # Get the current filtered database
    filtered_db <- filtered_database()
    
    # Check if it's NULL and return appropriate value
    if (is.null(filtered_db)) {
      return(NULL)
    }
    
    # Format the database for download
    format_database_for_download(filtered_db)
  })
  
  # Render user selected data table output
  output$data_table <- DT::renderDT({
    # Get the display data
    display_data <- display_data_table()
    
    # Return NULL or empty table if no data
    if (is.null(display_data)) {
      return(datatable(data.frame(), options = list(pageLength = 10)))
    }
    
    datatable(
      data = display_data,
      options = list(
        dom = 't',
        pageLength = 10,
        scrollX = TRUE
      ),
      rownames = FALSE,
      filter = 'none',
      class = 'cell-border stripe'
    )
  })
  
  # Download handler
  output$download_data <- downloadHandler(
    filename = function() {
      paste("austraits-6.0.0-", Sys.Date(), ".csv", sep = "")
    },
    content = function(file) {
      # Get the current download data
      data_to_download <- download_data_table()
      
      # Handle NULL or empty data case
      if (is.null(data_to_download) || nrow(data_to_download) == 0) {
        data_to_download <- data.frame(message = "No data selected")
      }
      
      utils::write.csv(data_to_download, file, row.names = FALSE)
    }
  )
}